{"version":3,"sources":["container/GraphContainer.js","App.js","index.js"],"names":["SERVER","GraphContainer","props","state","graph","nodes","edges","visited_tags","Set","nodes_id_map","nodes_tag_map","last_used_id","fetch","then","resp","json","data","tag","reloadGraph","tag_id","filter","e","to","length","clicked_tag","clicked_id","source_id","id","this","console","log","encodeURIComponent","add","forEach","each_domain","t","tag_name","push","from","label","shape","map","n","border_width","getNumEdges","borderWidth","network","setData","setState","source_tag","init","getNetwork","physics","enabled","stabilization","iterations","options","color","arrows","height","window","innerHeight","events","doubleClick","event","node_id","node_name","hold","has","extendGraph","React","Component","App","className","style","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.e240f6ac.chunk.js","sourcesContent":["import React from 'react';\nimport Graph from \"react-graph-vis\";\n\nconst SERVER = \"https://api.sok.runtimeerrorstudio.com/\";\n\n// Number of tags from each domain\nconst NUM_TAGS = 5;\n\nclass GraphContainer extends React.Component {\n    \n    constructor(props) {\n        super(props);\n\n        this.state = {\n            graph: {\n                nodes: [],\n                edges: [],\n            },            \n            visited_tags: new Set(),\n            // Hashmap: ID -> Tag\n            nodes_id_map: {},\n            // Hashmap: Tag -> ID\n            nodes_tag_map: {},\n            last_used_id: 0,\n        };\n    }\n\n    init() {\n        fetch(SERVER + \"random\")\n            .then(resp => resp.json())\n            .then(data => data[\"tag\"])\n            .then(tag => this.reloadGraph(tag));\n    }\n\n    getNumEdges(tag_id, edges) {\n        // Return the number of edges a given tag ID is being connected to\n        return edges.filter(e => e.to === tag_id).length;\n    }\n    \n\n    extendGraph(clicked_tag, clicked_id) {\n        /*\n            Extend existing graph instead of re-rendering the whole thing\n                given a tag that user has clicked and its ID\n        */\n        // Keep track of ID for current tag as source\n        // Current tag has already been in the nodes list, no need to add\n        let source_id = clicked_id;\n        let id = this.state.last_used_id;\n        let nodes = this.state.graph.nodes;\n        let edges = this.state.graph.edges;\n        console.log(edges, nodes);\n        let nodes_id_map = this.state.nodes_id_map;\n        let nodes_tag_map = this.state.nodes_tag_map;\n        let visited_tags = this.state.visited_tags;\n\n        fetch(SERVER + \"getTopN?n=\"+ NUM_TAGS + \"&tag=\" + encodeURIComponent(clicked_tag))\n            .then(resp => resp.json())\n            .then(data => {\n                visited_tags.add(clicked_tag);\n                data[\"ds\"].forEach(each_domain => {\n                    let domain_name = each_domain[\"d\"]\n                    let tags = each_domain[\"ts\"]\n                    tags.forEach(t => {\n                        let tag_name = t[\"t\"];\n                        if (tag_name in nodes_tag_map) {\n                            console.log(tag_name, \"already exists\");\n                            edges.push({\n                                from: source_id,\n                                to: nodes_tag_map[tag_name],\n                            });\n                        } else {\n                            console.log(tag_name, \"is new\");\n                            // Add edges from source to iter'd tag\n                            edges.push({\n                                from: source_id,\n                                to: id,\n                            });\n                            nodes.push({\n                                id: id,\n                                label: tag_name,\n                                shape: \"box\",\n                            });\n                            // Add ID to hashmap for search & vice versa\n                            nodes_id_map[id] = tag_name;\n                            nodes_tag_map[tag_name] = id;\n                            console.log(id);\n                            id ++;\n                        }\n                    });\n                });\n            })\n            .then(data => {\n                // Update border width for all nodes\n                nodes = nodes.map(n => {\n                    // Calculate the border width before inserting into nodes\n                    let id = nodes_tag_map[n.label];\n                    let border_width = this.getNumEdges(id, edges);\n                    n.borderWidth = border_width;\n                    return n;\n                });\n\n                // Need the below two lines to re-draw the graph for some reason\n                const {network} = this.state;\n                network.setData({\n                    nodes,\n                    edges,\n                });\n\n                this.setState({\n                    graph: {\n                        nodes: nodes,\n                        edges: edges,\n                    },\n                    nodes_id_map: nodes_id_map,\n                    nodes_tag_map: nodes_tag_map,\n                    visited_tags: visited_tags,\n                    last_used_id: id,\n                }, () => console.log(\"extend graph done\", this.state.graph));\n            });\n    }\n\n    reloadGraph(source_tag) {\n        /*\n            Re-render graph with a new source_tag\n        */\n        // Init source tag as id 0\n        let source_id = 0;\n        let id = 1;\n        let nodes = [{ id: source_id, label: source_tag, shape: \"box\" }];\n        let edges = [];\n        let nodes_id_map = {};\n        let nodes_tag_map = {};\n        nodes_id_map[source_id] = source_tag;\n        nodes_tag_map[source_tag] = source_id;\n        let visited_tags = this.state.visited_tags;\n        fetch(SERVER + \"getTopN?n=\" + NUM_TAGS + \"&tag=\" + encodeURIComponent(source_tag))\n            .then(resp => resp.json())\n            .then(data => {\n                    visited_tags.add(source_tag)\n                    data[\"ds\"].forEach(each_domain => {\n                        let domain_name = each_domain[\"d\"];\n                        let tags = each_domain[\"ts\"];\n                        tags.forEach(t => {\n                            let tag_name = t[\"t\"];\n                            // Don't add duplicated tags\n                            if (!(tag_name in nodes_tag_map)) {\n                                nodes.push({\n                                    id: id,\n                                    label: tag_name,\n                                    shape: \"box\",\n                                });\n                                // Add ID to hashmap for search & vice versa\n                                nodes_id_map[id] = tag_name;\n                                nodes_tag_map[tag_name] = id;\n                                // Add edges from source to iter'd tag\n                                edges.push({\n                                    from: source_id,\n                                    to: id,\n                                });\n                                id ++;\n                            }\n                        });\n                    });\n                }\n            )\n            .then(data => {\n\n                // Need the below two lines to re-draw the graph for some reason\n                const {network} = this.state;\n                network.setData({\n                    nodes,\n                    edges,\n                });\n\n                this.setState({\n                    graph: {\n                        nodes: nodes,\n                        edges: edges,\n                    },\n                    nodes_id_map: nodes_id_map,\n                    nodes_tag_map: nodes_tag_map,\n                    visited_tags: visited_tags,\n                    last_used_id: id,\n                }, () => console.log(\"reload graph done\", this.state));\n            });\n    }\n\n    componentDidMount() {\n        this.init();\n    }\n\n\n\n    render() {\n        return (\n            <div>\n                <Graph \n                    graph={this.state.graph}\n                    getNetwork={network => this.setState({ network })}\n                    physics = {{ \n                        enabled: true, \n                        stabilization: { \n                            iterations: 0\n                        }\n                    }}\n                    options = {{\n                        edges: {\n                            color: \"#B8E9DE\",\n                            arrows: {\n                                to: { \n                                    enabled: false,\n                                }\n                            },\n                        },\n                        height: window.innerHeight * 0.95 + \"px\",\n                    }}\n                    events = {{\n                        doubleClick: (event) => {\n                            if (event.nodes.length > 0){\n                                let node_id = event.nodes[0];\n                                let node_name = this.state.nodes_id_map[node_id];\n                                this.setState({\n                                    nodes: [],\n                                    visited_tags: new Set(),\n                                    nodes_id_map: {},\n                                    nodes_tag_map: {},\n                                    edges: [],\n                                    id: 0,\n                                }, () => this.reloadGraph(node_name));\n                            }\n                        },\n                        hold: (event) => {\n                            if (event.nodes.length > 0){\n                                let node_id = event.nodes[0];\n                                let node_name = this.state.nodes_id_map[node_id];\n                                if (!this.state.visited_tags.has(node_name)) {\n                                    this.extendGraph(node_name, node_id);\n                                }\n                            }\n                        }\n                    }}\n                />\n            </div>\n        );\n    }\n}\n\n\nexport default GraphContainer;","import Graph from './container/GraphContainer'\nimport GraphContainer from './container/GraphContainer';\n\nfunction App() {\n  return (\n    <div className=\"App\" style={{\"background-color\": \"#000000\"}}>\n      <GraphContainer />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);"],"sourceRoot":""}