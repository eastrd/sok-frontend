{"version":3,"sources":["container/GraphContainer.js","App.js","index.js"],"names":["SERVER","START_TAGS","START_TAG","Object","keys","Math","floor","random","length","NUM_TAGS","GraphContainer","props","state","graph","nodes","edges","visited_tags","Set","nodes_id_map","nodes_tag_map","last_used_id","tag_id","filter","e","to","clicked_tag","clicked_id","source_id","id","this","console","log","fetch","encodeURIComponent","then","resp","json","data","add","forEach","each_domain","t","tag_name","push","from","label","shape","map","n","border_width","getNumEdges","borderWidth","network","setData","setState","source_tag","reloadGraph","getNetwork","physics","enabled","stabilization","iterations","options","color","arrows","height","window","innerHeight","events","doubleClick","event","node_id","node_name","hold","has","extendGraph","React","Component","App","className","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.1a4ea977.chunk.js","sourcesContent":["import React from 'react';\nimport Graph from \"react-graph-vis\";\n\nconst SERVER = \"https://api.sok.runtimeerrorstudio.com/\";\n\n// A list of random value and their fixed size from array\nconst START_TAGS = {\n    \"universe\": 5, \n    \"computer-science\": 3,\n    \"brazilian-jiu-jitsu\": 5,\n    \"game\": 10,\n    \"marvel\": 10,\n    \"apocalypse\": 7,\n};\n\n// Get random key\nconst START_TAG = Object.keys(START_TAGS)[Math.floor(Math.random()*Object.keys(START_TAGS).length)];\nconst NUM_TAGS = START_TAGS[START_TAG];\n\nclass GraphContainer extends React.Component {\n    \n    constructor(props) {\n        super(props);\n\n        this.state = {\n            graph: {\n                nodes: [],\n                edges: [],\n            },            \n            visited_tags: new Set(),\n            // Hashmap: ID -> Tag\n            nodes_id_map: {},\n            // Hashmap: Tag -> ID\n            nodes_tag_map: {},\n            last_used_id: 0,\n        };\n    }\n\n    getNumEdges(tag_id, edges) {\n        // Return the number of edges a given tag ID is being connected to\n        return edges.filter(e => e.to === tag_id).length;\n    }\n    \n\n    extendGraph(clicked_tag, clicked_id) {\n        /*\n            Extend existing graph instead of re-rendering the whole thing\n                given a tag that user has clicked and its ID\n        */\n        // Keep track of ID for current tag as source\n        // Current tag has already been in the nodes list, no need to add\n        let source_id = clicked_id;\n        let id = this.state.last_used_id;\n        let nodes = this.state.graph.nodes;\n        let edges = this.state.graph.edges;\n        console.log(edges, nodes);\n        let nodes_id_map = this.state.nodes_id_map;\n        let nodes_tag_map = this.state.nodes_tag_map;\n        let visited_tags = this.state.visited_tags;\n\n        fetch(SERVER + \"getTopN?n=\"+ NUM_TAGS + \"&tag=\" + encodeURIComponent(clicked_tag))\n            .then(resp => resp.json())\n            .then(data => {\n                visited_tags.add(clicked_tag);\n                data[\"ds\"].forEach(each_domain => {\n                    let domain_name = each_domain[\"d\"]\n                    let tags = each_domain[\"ts\"]\n                    tags.forEach(t => {\n                        let tag_name = t[\"t\"];\n                        if (tag_name in nodes_tag_map) {\n                            console.log(tag_name, \"already exists\");\n                            edges.push({\n                                from: source_id,\n                                to: nodes_tag_map[tag_name],\n                            });\n                        } else {\n                            console.log(tag_name, \"is new\");\n                            // Add edges from source to iter'd tag\n                            edges.push({\n                                from: source_id,\n                                to: id,\n                            });\n                            nodes.push({\n                                id: id,\n                                label: tag_name,\n                                shape: \"box\",\n                            });\n                            // Add ID to hashmap for search & vice versa\n                            nodes_id_map[id] = tag_name;\n                            nodes_tag_map[tag_name] = id;\n                            console.log(id);\n                            id ++;\n                        }\n                    });\n                });\n            })\n            .then(data => {\n                // Update border width for all nodes\n                nodes = nodes.map(n => {\n                    // Calculate the border width before inserting into nodes\n                    let id = nodes_tag_map[n.label];\n                    let border_width = this.getNumEdges(id, edges);\n                    n.borderWidth = border_width;\n                    return n;\n                });\n\n                // Need the below two lines to re-draw the graph for some reason\n                const {network} = this.state;\n                network.setData({\n                    nodes,\n                    edges,\n                });\n\n                this.setState({\n                    graph: {\n                        nodes: nodes,\n                        edges: edges,\n                    },\n                    nodes_id_map: nodes_id_map,\n                    nodes_tag_map: nodes_tag_map,\n                    visited_tags: visited_tags,\n                    last_used_id: id,\n                }, () => console.log(\"extend graph done\", this.state.graph));\n            });\n    }\n\n    reloadGraph(source_tag) {\n        /*\n            Re-render graph with a new source_tag\n        */\n        // Init source tag as id 0\n        let source_id = 0;\n        let id = 1;\n        let nodes = [{ id: source_id, label: source_tag, shape: \"box\" }];\n        let edges = [];\n        let nodes_id_map = {};\n        let nodes_tag_map = {};\n        nodes_id_map[source_id] = source_tag;\n        nodes_tag_map[source_tag] = source_id;\n        let visited_tags = this.state.visited_tags;\n        fetch(SERVER + \"getTopN?n=\" + NUM_TAGS + \"&tag=\" + encodeURIComponent(source_tag))\n            .then(resp => resp.json())\n            .then(data => {\n                    visited_tags.add(source_tag)\n                    data[\"ds\"].forEach(each_domain => {\n                        let domain_name = each_domain[\"d\"];\n                        let tags = each_domain[\"ts\"];\n                        tags.forEach(t => {\n                            let tag_name = t[\"t\"];\n                            // Don't add duplicated tags\n                            if (!(tag_name in nodes_tag_map)) {\n                                nodes.push({\n                                    id: id,\n                                    label: tag_name,\n                                    shape: \"box\",\n                                });\n                                // Add ID to hashmap for search & vice versa\n                                nodes_id_map[id] = tag_name;\n                                nodes_tag_map[tag_name] = id;\n                                // Add edges from source to iter'd tag\n                                edges.push({\n                                    from: source_id,\n                                    to: id,\n                                });\n                                id ++;\n                            }\n                        });\n                    });\n                }\n            )\n            .then(data => {\n\n                // Need the below two lines to re-draw the graph for some reason\n                const {network} = this.state;\n                network.setData({\n                    nodes,\n                    edges,\n                });\n\n                this.setState({\n                    graph: {\n                        nodes: nodes,\n                        edges: edges,\n                    },\n                    nodes_id_map: nodes_id_map,\n                    nodes_tag_map: nodes_tag_map,\n                    visited_tags: visited_tags,\n                    last_used_id: id,\n                }, () => console.log(\"reload graph done\", this.state));\n            });\n    }\n\n    componentDidMount() {\n        this.reloadGraph(START_TAG);\n    }\n\n\n    render() {\n        return (\n            <div>\n                <Graph \n                    graph={this.state.graph}\n                    getNetwork={network => this.setState({ network })}\n                    physics = {{ \n                        enabled: true, \n                        stabilization: { \n                            iterations: 0\n                        }\n                    }}\n                    options = {{\n                        edges: {\n                            color: \"#000000\",\n                            arrows: {\n                                to: { \n                                    enabled: false,\n                                }\n                            },\n                        },\n                        height: window.innerHeight * 0.95 + \"px\",\n                    }}\n                    events = {{\n                        doubleClick: (event) => {\n                            if (event.nodes.length > 0){\n                                let node_id = event.nodes[0];\n                                let node_name = this.state.nodes_id_map[node_id];\n                                this.setState({\n                                    nodes: [],\n                                    visited_tags: new Set(),\n                                    nodes_id_map: {},\n                                    nodes_tag_map: {},\n                                    edges: [],\n                                    id: 0,\n                                }, () => this.reloadGraph(node_name));\n                            }\n                        },\n                        hold: (event) => {\n                            if (event.nodes.length > 0){\n                                let node_id = event.nodes[0];\n                                let node_name = this.state.nodes_id_map[node_id];\n                                if (!this.state.visited_tags.has(node_name)) {\n                                    this.extendGraph(node_name, node_id);\n                                }\n                            }\n                        }\n                    }}\n                />\n            </div>\n        );\n    }\n}\n\n\nexport default GraphContainer;","import Graph from './container/GraphContainer'\nimport GraphContainer from './container/GraphContainer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <GraphContainer />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);"],"sourceRoot":""}